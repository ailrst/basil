// File generated by the BNF Converter (bnfc 2.9.5).

package basil_ir;
import scala.jdk.CollectionConverters.*
import org.antlr.v4.runtime.{CharStreams, CommonTokenStream, Token}

/*** Visitor Design Pattern Skeleton. ***/

/* This extends the common visitor design pattern.
   Tests show it to be slightly less efficient than the
   instanceof method, but easier to use.
   Replace the R and A parameters with the desired return
   and context types.*/



def parse(s: String) = {
  val lexer = BasilIRLexer(CharStreams.fromFileName(s));
  val tokens = CommonTokenStream(lexer)
  val p = BasilIRParser(tokens) 

  val pc = p.start_Program();
  val ast = pc.result;
  println(PrettyPrinter.print(ast));
}

class VisitSkel
{
  class ProgramVisitor[R,A] extends basil_ir.Absyn.Program.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.Prog, arg: A) : R = 
    { /* Code for Prog goes here */
      for (x : basil_ir.Absyn.Declaration <- p.listdeclaration_.asScala) {
        x.accept(new DeclarationVisitor[R,A](), arg);
      }
      ???
    }
  }
  class DeclarationVisitor[R,A] extends basil_ir.Absyn.Declaration.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.LetDecl, arg: A) : R = 
    { /* Code for LetDecl goes here */
      //p.bident_;
      p.mexpr_.accept(new MExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.MemDecl, arg: A) : R = 
    { /* Code for MemDecl goes here */
      //p.bident_;
      p.type_.accept(new TypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.VarDecl, arg: A) : R = 
    { /* Code for VarDecl goes here */
      //p.bident_;
      p.type_.accept(new TypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.Procedure, arg: A) : R = 
    { /* Code for Procedure goes here */
      //p.bident_;
      for (x : basil_ir.Absyn.Params <- p.listparams_1.asScala) {
        x.accept(new ParamsVisitor[R,A](), arg);
      }
      for (x : basil_ir.Absyn.Params <- p.listparams_2.asScala) {
        x.accept(new ParamsVisitor[R,A](), arg);
      }
      p.procdef_.accept(new ProcDefVisitor[R,A](), arg);
      ???
    }
  }
  class MExprVisitor[R,A] extends basil_ir.Absyn.MExpr.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.MSym, arg: A) : R = 
    { /* Code for MSym goes here */
      //p.bident_;
      ???
    }
    def visit(p : basil_ir.Absyn.BlockM, arg: A) : R = 
    { /* Code for BlockM goes here */
      p.block_.accept(new BlockVisitor[R,A](), arg);
      ???
    }
  }
  class IntTypeVisitor[R,A] extends basil_ir.Absyn.IntType.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.IntT, arg: A) : R = 
    { /* Code for IntT goes here */
      ???
    }
  }
  class BoolTypeVisitor[R,A] extends basil_ir.Absyn.BoolType.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BoolT, arg: A) : R = 
    { /* Code for BoolT goes here */
      ???
    }
  }
  class MapTypeVisitor[R,A] extends basil_ir.Absyn.MapType.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.MapT, arg: A) : R = 
    { /* Code for MapT goes here */
      p.type_1.accept(new TypeVisitor[R,A](), arg);
      //p.beginlist_;
      p.type_2.accept(new TypeVisitor[R,A](), arg);
      //p.endlist_;
      ???
    }
  }
  class BVTypeVisitor[R,A] extends basil_ir.Absyn.BVType.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BVT, arg: A) : R = 
    { /* Code for BVT goes here */
      //p.bvtype_;
      ???
    }
  }
  class TypeVisitor[R,A] extends basil_ir.Absyn.Type.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.TypeIntType, arg: A) : R = 
    { /* Code for TypeIntType goes here */
      p.inttype_.accept(new IntTypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.TypeBoolType, arg: A) : R = 
    { /* Code for TypeBoolType goes here */
      p.booltype_.accept(new BoolTypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.TypeMapType, arg: A) : R = 
    { /* Code for TypeMapType goes here */
      p.maptype_.accept(new MapTypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.TypeBVType, arg: A) : R = 
    { /* Code for TypeBVType goes here */
      p.bvtype_.accept(new BVTypeVisitor[R,A](), arg);
      ???
    }
  }
  class IntValVisitor[R,A] extends basil_ir.Absyn.IntVal.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.HexInt, arg: A) : R = 
    { /* Code for HexInt goes here */
      //p.integerhex_;
      ???
    }
    def visit(p : basil_ir.Absyn.DecInt, arg: A) : R = 
    { /* Code for DecInt goes here */
      //p.integer_;
      ???
    }
  }
  class AddrAttrVisitor[R,A] extends basil_ir.Absyn.AddrAttr.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.AddrAttrSome, arg: A) : R = 
    { /* Code for AddrAttrSome goes here */
      //p.beginrec_;
      p.intval_.accept(new IntValVisitor[R,A](), arg);
      //p.endrec_;
      ???
    }
    def visit(p : basil_ir.Absyn.AddrAttrNone, arg: A) : R = 
    { /* Code for AddrAttrNone goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.AddrAttrEmpty, arg: A) : R = 
    { /* Code for AddrAttrEmpty goes here */
      //p.beginrec_;
      //p.endrec_;
      ???
    }
  }
  class EndianVisitor[R,A] extends basil_ir.Absyn.Endian.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.LittleEndian, arg: A) : R = 
    { /* Code for LittleEndian goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BigEndian, arg: A) : R = 
    { /* Code for BigEndian goes here */
      ???
    }
  }
  class StatementVisitor[R,A] extends basil_ir.Absyn.Statement.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.Assign, arg: A) : R = 
    { /* Code for Assign goes here */
      p.lvar_.accept(new LVarVisitor[R,A](), arg);
      p.expr_.accept(new ExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.SLoad, arg: A) : R = 
    { /* Code for SLoad goes here */
      p.lvar_.accept(new LVarVisitor[R,A](), arg);
      p.endian_.accept(new EndianVisitor[R,A](), arg);
      //p.bident_;
      p.expr_.accept(new ExprVisitor[R,A](), arg);
      p.intval_.accept(new IntValVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.SStore, arg: A) : R = 
    { /* Code for SStore goes here */
      p.endian_.accept(new EndianVisitor[R,A](), arg);
      //p.bident_;
      p.expr_1.accept(new ExprVisitor[R,A](), arg);
      p.expr_2.accept(new ExprVisitor[R,A](), arg);
      p.intval_.accept(new IntValVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.DirectCall, arg: A) : R = 
    { /* Code for DirectCall goes here */
      p.calllvars_.accept(new CallLVarsVisitor[R,A](), arg);
      //p.bident_;
      for (x : basil_ir.Absyn.Expr <- p.listexpr_.asScala) {
        x.accept(new ExprVisitor[R,A](), arg);
      }
      ???
    }
    def visit(p : basil_ir.Absyn.IndirectCall, arg: A) : R = 
    { /* Code for IndirectCall goes here */
      p.expr_.accept(new ExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.Assume, arg: A) : R = 
    { /* Code for Assume goes here */
      p.expr_.accept(new ExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.Assert, arg: A) : R = 
    { /* Code for Assert goes here */
      p.expr_.accept(new ExprVisitor[R,A](), arg);
      ???
    }
  }
  class CallLVarsVisitor[R,A] extends basil_ir.Absyn.CallLVars.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.NoOutParams, arg: A) : R = 
    { /* Code for NoOutParams goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.LocalVars, arg: A) : R = 
    { /* Code for LocalVars goes here */
      for (x : basil_ir.Absyn.LVar <- p.listlvar_.asScala) {
        x.accept(new LVarVisitor[R,A](), arg);
      }
      ???
    }
    def visit(p : basil_ir.Absyn.ListOutParams, arg: A) : R = 
    { /* Code for ListOutParams goes here */
      for (x : basil_ir.Absyn.LVar <- p.listlvar_.asScala) {
        x.accept(new LVarVisitor[R,A](), arg);
      }
      ???
    }
  }
  class JumpVisitor[R,A] extends basil_ir.Absyn.Jump.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.GoTo, arg: A) : R = 
    { /* Code for GoTo goes here */
      for (x : String <- p.listbident_.asScala) {
        //x;
      }
      ???
    }
    def visit(p : basil_ir.Absyn.Unreachable, arg: A) : R = 
    { /* Code for Unreachable goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.Return, arg: A) : R = 
    { /* Code for Return goes here */
      for (x : basil_ir.Absyn.Expr <- p.listexpr_.asScala) {
        x.accept(new ExprVisitor[R,A](), arg);
      }
      ???
    }
  }
  class LVarVisitor[R,A] extends basil_ir.Absyn.LVar.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.LVarDef, arg: A) : R = 
    { /* Code for LVarDef goes here */
      //p.bident_;
      p.type_.accept(new TypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.GlobalLVar, arg: A) : R = 
    { /* Code for GlobalLVar goes here */
      //p.bident_;
      p.type_.accept(new TypeVisitor[R,A](), arg);
      ???
    }
  }
  class BlockVisitor[R,A] extends basil_ir.Absyn.Block.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.B, arg: A) : R = 
    { /* Code for B goes here */
      //p.bident_;
      p.addrattr_.accept(new AddrAttrVisitor[R,A](), arg);
      //p.beginlist_;
      for (x : basil_ir.Absyn.Statement <- p.liststatement_.asScala) {
        x.accept(new StatementVisitor[R,A](), arg);
      }
      p.jump_.accept(new JumpVisitor[R,A](), arg);
      //p.endlist_;
      ???
    }
  }
  class PEntryVisitor[R,A] extends basil_ir.Absyn.PEntry.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.EntrySome, arg: A) : R = 
    { /* Code for EntrySome goes here */
      //p.str_;
      ???
    }
    def visit(p : basil_ir.Absyn.EntryNone, arg: A) : R = 
    { /* Code for EntryNone goes here */
      ???
    }
  }
  class PAddressVisitor[R,A] extends basil_ir.Absyn.PAddress.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.AddrSome, arg: A) : R = 
    { /* Code for AddrSome goes here */
      p.intval_.accept(new IntValVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.AddrNone, arg: A) : R = 
    { /* Code for AddrNone goes here */
      ???
    }
  }
  class InternalBlocksVisitor[R,A] extends basil_ir.Absyn.InternalBlocks.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BSome, arg: A) : R = 
    { /* Code for BSome goes here */
      //p.beginlist_;
      for (x : basil_ir.Absyn.Block <- p.listblock_.asScala) {
        x.accept(new BlockVisitor[R,A](), arg);
      }
      //p.endlist_;
      ???
    }
    def visit(p : basil_ir.Absyn.BNone, arg: A) : R = 
    { /* Code for BNone goes here */
      ???
    }
  }
  class ProcDefVisitor[R,A] extends basil_ir.Absyn.ProcDef.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.PD, arg: A) : R = 
    { /* Code for PD goes here */
      //p.beginrec_;
      //p.str_;
      p.paddress_.accept(new PAddressVisitor[R,A](), arg);
      p.pentry_.accept(new PEntryVisitor[R,A](), arg);
      p.internalblocks_.accept(new InternalBlocksVisitor[R,A](), arg);
      //p.endrec_;
      ???
    }
  }
  class ParamsVisitor[R,A] extends basil_ir.Absyn.Params.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.Param, arg: A) : R = 
    { /* Code for Param goes here */
      //p.bident_;
      p.type_.accept(new TypeVisitor[R,A](), arg);
      ???
    }
  }
  class ExprVisitor[R,A] extends basil_ir.Absyn.Expr.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.RVar, arg: A) : R = 
    { /* Code for RVar goes here */
      //p.bident_;
      p.type_.accept(new TypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.BinaryExpr, arg: A) : R = 
    { /* Code for BinaryExpr goes here */
      p.binop_.accept(new BinOpVisitor[R,A](), arg);
      p.expr_1.accept(new ExprVisitor[R,A](), arg);
      p.expr_2.accept(new ExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.UnaryExpr, arg: A) : R = 
    { /* Code for UnaryExpr goes here */
      p.unop_.accept(new UnOpVisitor[R,A](), arg);
      p.expr_.accept(new ExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.ZeroExtend, arg: A) : R = 
    { /* Code for ZeroExtend goes here */
      p.intval_.accept(new IntValVisitor[R,A](), arg);
      p.expr_.accept(new ExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.SignExtend, arg: A) : R = 
    { /* Code for SignExtend goes here */
      p.intval_.accept(new IntValVisitor[R,A](), arg);
      p.expr_.accept(new ExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.Extract, arg: A) : R = 
    { /* Code for Extract goes here */
      p.intval_1.accept(new IntValVisitor[R,A](), arg);
      p.intval_2.accept(new IntValVisitor[R,A](), arg);
      p.expr_.accept(new ExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.Concat, arg: A) : R = 
    { /* Code for Concat goes here */
      p.expr_1.accept(new ExprVisitor[R,A](), arg);
      p.expr_2.accept(new ExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.BVLiteral, arg: A) : R = 
    { /* Code for BVLiteral goes here */
      p.intval_.accept(new IntValVisitor[R,A](), arg);
      p.bvtype_.accept(new BVTypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.IntLiteral, arg: A) : R = 
    { /* Code for IntLiteral goes here */
      p.intval_.accept(new IntValVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.TrueLiteral, arg: A) : R = 
    { /* Code for TrueLiteral goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.FalseLiteral, arg: A) : R = 
    { /* Code for FalseLiteral goes here */
      ???
    }
  }
  class UnOpVisitor[R,A] extends basil_ir.Absyn.UnOp.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.UnOp_bvnot, arg: A) : R = 
    { /* Code for UnOp_bvnot goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.UnOp_bvneg, arg: A) : R = 
    { /* Code for UnOp_bvneg goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.UnOp_boolnot, arg: A) : R = 
    { /* Code for UnOp_boolnot goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.UnOp_intneg, arg: A) : R = 
    { /* Code for UnOp_intneg goes here */
      ???
    }
  }
  class BinOpVisitor[R,A] extends basil_ir.Absyn.BinOp.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BinOp_bvand, arg: A) : R = 
    { /* Code for BinOp_bvand goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvor, arg: A) : R = 
    { /* Code for BinOp_bvor goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvadd, arg: A) : R = 
    { /* Code for BinOp_bvadd goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvmul, arg: A) : R = 
    { /* Code for BinOp_bvmul goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvudiv, arg: A) : R = 
    { /* Code for BinOp_bvudiv goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvurem, arg: A) : R = 
    { /* Code for BinOp_bvurem goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvshl, arg: A) : R = 
    { /* Code for BinOp_bvshl goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvlshr, arg: A) : R = 
    { /* Code for BinOp_bvlshr goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvult, arg: A) : R = 
    { /* Code for BinOp_bvult goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvnand, arg: A) : R = 
    { /* Code for BinOp_bvnand goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvnor, arg: A) : R = 
    { /* Code for BinOp_bvnor goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvxor, arg: A) : R = 
    { /* Code for BinOp_bvxor goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvxnor, arg: A) : R = 
    { /* Code for BinOp_bvxnor goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvcomp, arg: A) : R = 
    { /* Code for BinOp_bvcomp goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvsub, arg: A) : R = 
    { /* Code for BinOp_bvsub goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvsdiv, arg: A) : R = 
    { /* Code for BinOp_bvsdiv goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvsrem, arg: A) : R = 
    { /* Code for BinOp_bvsrem goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvsmod, arg: A) : R = 
    { /* Code for BinOp_bvsmod goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvashr, arg: A) : R = 
    { /* Code for BinOp_bvashr goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvule, arg: A) : R = 
    { /* Code for BinOp_bvule goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvugt, arg: A) : R = 
    { /* Code for BinOp_bvugt goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvuge, arg: A) : R = 
    { /* Code for BinOp_bvuge goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvslt, arg: A) : R = 
    { /* Code for BinOp_bvslt goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvsle, arg: A) : R = 
    { /* Code for BinOp_bvsle goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvsgt, arg: A) : R = 
    { /* Code for BinOp_bvsgt goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvsge, arg: A) : R = 
    { /* Code for BinOp_bvsge goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bveq, arg: A) : R = 
    { /* Code for BinOp_bveq goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_bvneq, arg: A) : R = 
    { /* Code for BinOp_bvneq goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_intadd, arg: A) : R = 
    { /* Code for BinOp_intadd goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_intmul, arg: A) : R = 
    { /* Code for BinOp_intmul goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_intsub, arg: A) : R = 
    { /* Code for BinOp_intsub goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_intdiv, arg: A) : R = 
    { /* Code for BinOp_intdiv goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_intmod, arg: A) : R = 
    { /* Code for BinOp_intmod goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_inteq, arg: A) : R = 
    { /* Code for BinOp_inteq goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_intneq, arg: A) : R = 
    { /* Code for BinOp_intneq goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_intlt, arg: A) : R = 
    { /* Code for BinOp_intlt goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_intle, arg: A) : R = 
    { /* Code for BinOp_intle goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_intgt, arg: A) : R = 
    { /* Code for BinOp_intgt goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_intge, arg: A) : R = 
    { /* Code for BinOp_intge goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_booleq, arg: A) : R = 
    { /* Code for BinOp_booleq goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_boolneq, arg: A) : R = 
    { /* Code for BinOp_boolneq goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_booland, arg: A) : R = 
    { /* Code for BinOp_booland goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_boolor, arg: A) : R = 
    { /* Code for BinOp_boolor goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_boolimplies, arg: A) : R = 
    { /* Code for BinOp_boolimplies goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BinOp_boolequiv, arg: A) : R = 
    { /* Code for BinOp_boolequiv goes here */
      ???
    }
  }
}
