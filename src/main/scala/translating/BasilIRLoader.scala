// File generated by the BNF Converter (bnfc 2.9.5).

package basil_ir;
import scala.jdk.CollectionConverters.*

/*** Visitor Design Pattern Skeleton. ***/

/* This extends the common visitor design pattern.
   Tests show it to be slightly less efficient than the
   instanceof method, but easier to use.
   Replace the R and A parameters with the desired return
   and context types.*/

class VisitSkel
{
  class ProgramVisitor[R,A] extends basil_ir.Absyn.Program.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.Prog, arg: A) : R = 
    { /* Code for Prog goes here */
      for (x : basil_ir.Absyn.Declaration <- p.listdeclaration_.asScala) {
        x.accept(new DeclarationVisitor[R,A](), arg);
      }
      ???
    }
  }
  class DeclarationVisitor[R,A] extends basil_ir.Absyn.Declaration.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.LetDecl, arg: A) : R = 
    { /* Code for LetDecl goes here */
      //p.bident_;
      p.mexpr_.accept(new MExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.MemDecl, arg: A) : R = 
    { /* Code for MemDecl goes here */
      //p.bident_;
      p.type_.accept(new TypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.VarDecl, arg: A) : R = 
    { /* Code for VarDecl goes here */
      //p.bident_;
      p.type_.accept(new TypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.Procedure, arg: A) : R = 
    { /* Code for Procedure goes here */
      //p.bident_;
      for (x : basil_ir.Absyn.Params <- p.listparams_1.asScala) {
        x.accept(new ParamsVisitor[R,A](), arg);
      }
      for (x : basil_ir.Absyn.Params <- p.listparams_2.asScala) {
        x.accept(new ParamsVisitor[R,A](), arg);
      }
      p.procdef_.accept(new ProcDefVisitor[R,A](), arg);
      ???
    }
  }
  class MExprVisitor[R,A] extends basil_ir.Absyn.MExpr.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.MSym, arg: A) : R = 
    { /* Code for MSym goes here */
      //p.bident_;
      ???
    }
    def visit(p : basil_ir.Absyn.BlockM, arg: A) : R = 
    { /* Code for BlockM goes here */
      p.block_.accept(new BlockVisitor[R,A](), arg);
      ???
    }
  }
  class IntTypeVisitor[R,A] extends basil_ir.Absyn.IntType.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.IntT, arg: A) : R = 
    { /* Code for IntT goes here */
      ???
    }
  }
  class BoolTypeVisitor[R,A] extends basil_ir.Absyn.BoolType.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BoolT, arg: A) : R = 
    { /* Code for BoolT goes here */
      ???
    }
  }
  class MapTypeVisitor[R,A] extends basil_ir.Absyn.MapType.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.MapT, arg: A) : R = 
    { /* Code for MapT goes here */
      p.type_1.accept(new TypeVisitor[R,A](), arg);
      p.type_2.accept(new TypeVisitor[R,A](), arg);
      ???
    }
  }
  class BVTypeVisitor[R,A] extends basil_ir.Absyn.BVType.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.ShortBVT, arg: A) : R = 
    { /* Code for ShortBVT goes here */
      //p.bvtype_;
      ???
    }
    def visit(p : basil_ir.Absyn.BitvectorType, arg: A) : R = 
    { /* Code for BitvectorType goes here */
      p.intlit_.accept(new IntLitVisitor[R,A](), arg);
      ???
    }
  }
  class TypeVisitor[R,A] extends basil_ir.Absyn.Type.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.TypeIntType, arg: A) : R = 
    { /* Code for TypeIntType goes here */
      p.inttype_.accept(new IntTypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.TypeBoolType, arg: A) : R = 
    { /* Code for TypeBoolType goes here */
      p.booltype_.accept(new BoolTypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.TypeMapType, arg: A) : R = 
    { /* Code for TypeMapType goes here */
      p.maptype_.accept(new MapTypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.TypeBVType, arg: A) : R = 
    { /* Code for TypeBVType goes here */
      p.bvtype_.accept(new BVTypeVisitor[R,A](), arg);
      ???
    }
  }
  class IntLitVisitor[R,A] extends basil_ir.Absyn.IntLit.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.HexInt, arg: A) : R = 
    { /* Code for HexInt goes here */
      //p.integerhex_;
      ???
    }
    def visit(p : basil_ir.Absyn.DecInt, arg: A) : R = 
    { /* Code for DecInt goes here */
      //p.integer_;
      ???
    }
  }
  class AddrAttrVisitor[R,A] extends basil_ir.Absyn.AddrAttr.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.AddrAttrSome, arg: A) : R = 
    { /* Code for AddrAttrSome goes here */
      p.intlit_.accept(new IntLitVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.AddrAttrNone, arg: A) : R = 
    { /* Code for AddrAttrNone goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.AddrAttrEmpty, arg: A) : R = 
    { /* Code for AddrAttrEmpty goes here */
      ???
    }
  }
  class EndianVisitor[R,A] extends basil_ir.Absyn.Endian.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.LittleEndian, arg: A) : R = 
    { /* Code for LittleEndian goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BigEndian, arg: A) : R = 
    { /* Code for BigEndian goes here */
      ???
    }
  }
  class StatementVisitor[R,A] extends basil_ir.Absyn.Statement.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.AssignStmt, arg: A) : R = 
    { /* Code for AssignStmt goes here */
      p.assign_.accept(new AssignVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.SLoad, arg: A) : R = 
    { /* Code for SLoad goes here */
      p.bvlvar_.accept(new BVLVarVisitor[R,A](), arg);
      p.endian_.accept(new EndianVisitor[R,A](), arg);
      //p.bident_;
      p.bvexpr_.accept(new BVExprVisitor[R,A](), arg);
      p.intlit_.accept(new IntLitVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.SStore, arg: A) : R = 
    { /* Code for SStore goes here */
      p.endian_.accept(new EndianVisitor[R,A](), arg);
      //p.bident_;
      p.expr_.accept(new ExprVisitor[R,A](), arg);
      p.bvexpr_.accept(new BVExprVisitor[R,A](), arg);
      p.intlit_.accept(new IntLitVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.DirectCall, arg: A) : R = 
    { /* Code for DirectCall goes here */
      //p.bident_;
      for (x : basil_ir.Absyn.Expr <- p.listexpr_.asScala) {
        x.accept(new ExprVisitor[R,A](), arg);
      }
      ???
    }
    def visit(p : basil_ir.Absyn.DirectCallReturnLocal, arg: A) : R = 
    { /* Code for DirectCallReturnLocal goes here */
      for (x : basil_ir.Absyn.LVar <- p.listlvar_.asScala) {
        x.accept(new LVarVisitor[R,A](), arg);
      }
      //p.bident_;
      for (x : basil_ir.Absyn.Expr <- p.listexpr_.asScala) {
        x.accept(new ExprVisitor[R,A](), arg);
      }
      ???
    }
    def visit(p : basil_ir.Absyn.DirectCallReturn, arg: A) : R = 
    { /* Code for DirectCallReturn goes here */
      for (x : basil_ir.Absyn.LVar <- p.listlvar_.asScala) {
        x.accept(new LVarVisitor[R,A](), arg);
      }
      //p.bident_;
      for (x : basil_ir.Absyn.Expr <- p.listexpr_.asScala) {
        x.accept(new ExprVisitor[R,A](), arg);
      }
      ???
    }
    def visit(p : basil_ir.Absyn.IndirectCall, arg: A) : R = 
    { /* Code for IndirectCall goes here */
      p.expr_.accept(new ExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.Assume, arg: A) : R = 
    { /* Code for Assume goes here */
      p.expr_.accept(new ExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.Assert, arg: A) : R = 
    { /* Code for Assert goes here */
      p.expr_.accept(new ExprVisitor[R,A](), arg);
      ???
    }
  }
  class AssignVisitor[R,A] extends basil_ir.Absyn.Assign.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.IntAssign, arg: A) : R = 
    { /* Code for IntAssign goes here */
      p.intlvar_.accept(new IntLVarVisitor[R,A](), arg);
      p.intexpr_.accept(new IntExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.BVAssign, arg: A) : R = 
    { /* Code for BVAssign goes here */
      p.bvlvar_.accept(new BVLVarVisitor[R,A](), arg);
      p.bvexpr_.accept(new BVExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.BoolAssign, arg: A) : R = 
    { /* Code for BoolAssign goes here */
      p.boollvar_.accept(new BoolLVarVisitor[R,A](), arg);
      p.logexpr_.accept(new LogExprVisitor[R,A](), arg);
      ???
    }
  }
  class JumpVisitor[R,A] extends basil_ir.Absyn.Jump.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.GoTo, arg: A) : R = 
    { /* Code for GoTo goes here */
      for (x : String <- p.listbident_.asScala) {
        //x;
      }
      ???
    }
    def visit(p : basil_ir.Absyn.Unreachable, arg: A) : R = 
    { /* Code for Unreachable goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.Return, arg: A) : R = 
    { /* Code for Return goes here */
      for (x : basil_ir.Absyn.Expr <- p.listexpr_.asScala) {
        x.accept(new ExprVisitor[R,A](), arg);
      }
      ???
    }
  }
  class LVarVisitor[R,A] extends basil_ir.Absyn.LVar.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.LVarIntLVar, arg: A) : R = 
    { /* Code for LVarIntLVar goes here */
      p.intlvar_.accept(new IntLVarVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.LVarBVLVar, arg: A) : R = 
    { /* Code for LVarBVLVar goes here */
      p.bvlvar_.accept(new BVLVarVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.LVarBoolLVar, arg: A) : R = 
    { /* Code for LVarBoolLVar goes here */
      p.boollvar_.accept(new BoolLVarVisitor[R,A](), arg);
      ???
    }
  }
  class BVLVarVisitor[R,A] extends basil_ir.Absyn.BVLVar.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.LocalBVLVar, arg: A) : R = 
    { /* Code for LocalBVLVar goes here */
      //p.bident_;
      p.bvtype_.accept(new BVTypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.GlobalBVLVar, arg: A) : R = 
    { /* Code for GlobalBVLVar goes here */
      //p.bident_;
      p.bvtype_.accept(new BVTypeVisitor[R,A](), arg);
      ???
    }
  }
  class IntLVarVisitor[R,A] extends basil_ir.Absyn.IntLVar.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.LocalIntLVar, arg: A) : R = 
    { /* Code for LocalIntLVar goes here */
      //p.bident_;
      p.inttype_.accept(new IntTypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.GlobalIntLVar, arg: A) : R = 
    { /* Code for GlobalIntLVar goes here */
      //p.bident_;
      p.inttype_.accept(new IntTypeVisitor[R,A](), arg);
      ???
    }
  }
  class BoolLVarVisitor[R,A] extends basil_ir.Absyn.BoolLVar.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.LocalBoolLVar, arg: A) : R = 
    { /* Code for LocalBoolLVar goes here */
      //p.bident_;
      p.booltype_.accept(new BoolTypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.GlobalBoolLVar, arg: A) : R = 
    { /* Code for GlobalBoolLVar goes here */
      //p.bident_;
      p.booltype_.accept(new BoolTypeVisitor[R,A](), arg);
      ???
    }
  }
  class BlockVisitor[R,A] extends basil_ir.Absyn.Block.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.B, arg: A) : R = 
    { /* Code for B goes here */
      //p.bident_;
      p.addrattr_.accept(new AddrAttrVisitor[R,A](), arg);
      for (x : basil_ir.Absyn.Statement <- p.liststatement_.asScala) {
        x.accept(new StatementVisitor[R,A](), arg);
      }
      p.jump_.accept(new JumpVisitor[R,A](), arg);
      ???
    }
  }
  class PEntryVisitor[R,A] extends basil_ir.Absyn.PEntry.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.EntrySome, arg: A) : R = 
    { /* Code for EntrySome goes here */
      p.block_.accept(new BlockVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.EntryNone, arg: A) : R = 
    { /* Code for EntryNone goes here */
      ???
    }
  }
  class PExitVisitor[R,A] extends basil_ir.Absyn.PExit.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.ESome, arg: A) : R = 
    { /* Code for ESome goes here */
      p.block_.accept(new BlockVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.ENone, arg: A) : R = 
    { /* Code for ENone goes here */
      ???
    }
  }
  class PAddressVisitor[R,A] extends basil_ir.Absyn.PAddress.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.AddrSome, arg: A) : R = 
    { /* Code for AddrSome goes here */
      p.intlit_.accept(new IntLitVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.AddrNone, arg: A) : R = 
    { /* Code for AddrNone goes here */
      ???
    }
  }
  class InternalBlocksVisitor[R,A] extends basil_ir.Absyn.InternalBlocks.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BSome, arg: A) : R = 
    { /* Code for BSome goes here */
      for (x : basil_ir.Absyn.Block <- p.listblock_.asScala) {
        x.accept(new BlockVisitor[R,A](), arg);
      }
      ???
    }
    def visit(p : basil_ir.Absyn.BNone, arg: A) : R = 
    { /* Code for BNone goes here */
      ???
    }
  }
  class ProcDefVisitor[R,A] extends basil_ir.Absyn.ProcDef.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.PD, arg: A) : R = 
    { /* Code for PD goes here */
      //p.str_;
      p.paddress_.accept(new PAddressVisitor[R,A](), arg);
      p.pentry_.accept(new PEntryVisitor[R,A](), arg);
      p.pexit_.accept(new PExitVisitor[R,A](), arg);
      p.internalblocks_.accept(new InternalBlocksVisitor[R,A](), arg);
      ???
    }
  }
  class ParamsVisitor[R,A] extends basil_ir.Absyn.Params.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.Param, arg: A) : R = 
    { /* Code for Param goes here */
      //p.bident_;
      p.type_.accept(new TypeVisitor[R,A](), arg);
      ???
    }
  }
  class ExprVisitor[R,A] extends basil_ir.Absyn.Expr.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BitvectorExpr, arg: A) : R = 
    { /* Code for BitvectorExpr goes here */
      p.bvexpr_.accept(new BVExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.LogicalExpr, arg: A) : R = 
    { /* Code for LogicalExpr goes here */
      p.logexpr_.accept(new LogExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.IntegerExpr, arg: A) : R = 
    { /* Code for IntegerExpr goes here */
      p.intexpr_.accept(new IntExprVisitor[R,A](), arg);
      ???
    }
  }
  class BVExprVisitor[R,A] extends basil_ir.Absyn.BVExpr.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BVBinary, arg: A) : R = 
    { /* Code for BVBinary goes here */
      p.bvbinop_.accept(new BVBinOpVisitor[R,A](), arg);
      p.bvexpr_1.accept(new BVExprVisitor[R,A](), arg);
      p.bvexpr_2.accept(new BVExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.BVUnary, arg: A) : R = 
    { /* Code for BVUnary goes here */
      p.bvunop_.accept(new BVUnOpVisitor[R,A](), arg);
      p.bvexpr_.accept(new BVExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.ZeroExtend, arg: A) : R = 
    { /* Code for ZeroExtend goes here */
      p.intlit_.accept(new IntLitVisitor[R,A](), arg);
      p.bvexpr_.accept(new BVExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.SignExtend, arg: A) : R = 
    { /* Code for SignExtend goes here */
      p.intlit_.accept(new IntLitVisitor[R,A](), arg);
      p.bvexpr_.accept(new BVExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.Extract, arg: A) : R = 
    { /* Code for Extract goes here */
      p.intlit_1.accept(new IntLitVisitor[R,A](), arg);
      p.intlit_2.accept(new IntLitVisitor[R,A](), arg);
      p.bvexpr_.accept(new BVExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.Concat, arg: A) : R = 
    { /* Code for Concat goes here */
      p.bvexpr_1.accept(new BVExprVisitor[R,A](), arg);
      p.bvexpr_2.accept(new BVExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.BVLiteral, arg: A) : R = 
    { /* Code for BVLiteral goes here */
      p.intlit_.accept(new IntLitVisitor[R,A](), arg);
      p.bvtype_.accept(new BVTypeVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.RBVVar, arg: A) : R = 
    { /* Code for RBVVar goes here */
      p.bvrvar_.accept(new BVRVarVisitor[R,A](), arg);
      ???
    }
  }
  class IntExprVisitor[R,A] extends basil_ir.Absyn.IntExpr.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.IntLiteral, arg: A) : R = 
    { /* Code for IntLiteral goes here */
      p.intlit_.accept(new IntLitVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.RIntVar, arg: A) : R = 
    { /* Code for RIntVar goes here */
      p.intrvar_.accept(new IntRVarVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.IntBinary, arg: A) : R = 
    { /* Code for IntBinary goes here */
      p.intbinop_.accept(new IntBinOpVisitor[R,A](), arg);
      p.intexpr_1.accept(new IntExprVisitor[R,A](), arg);
      p.intexpr_2.accept(new IntExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.IntNeg, arg: A) : R = 
    { /* Code for IntNeg goes here */
      p.intexpr_.accept(new IntExprVisitor[R,A](), arg);
      ???
    }
  }
  class LogExprVisitor[R,A] extends basil_ir.Absyn.LogExpr.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BVLogBinary, arg: A) : R = 
    { /* Code for BVLogBinary goes here */
      p.bvlogicalbinop_.accept(new BVLogicalBinOpVisitor[R,A](), arg);
      p.bvexpr_1.accept(new BVExprVisitor[R,A](), arg);
      p.bvexpr_2.accept(new BVExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.RLogVar, arg: A) : R = 
    { /* Code for RLogVar goes here */
      p.boolrvar_.accept(new BoolRVarVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.BoolLit, arg: A) : R = 
    { /* Code for BoolLit goes here */
      p.boolliteral_.accept(new BoolLiteralVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.IntLogBinary, arg: A) : R = 
    { /* Code for IntLogBinary goes here */
      p.intlogicalbinop_.accept(new IntLogicalBinOpVisitor[R,A](), arg);
      p.intexpr_1.accept(new IntExprVisitor[R,A](), arg);
      p.intexpr_2.accept(new IntExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.BoolLogBinOp, arg: A) : R = 
    { /* Code for BoolLogBinOp goes here */
      p.boolbinop_.accept(new BoolBinOpVisitor[R,A](), arg);
      p.logexpr_1.accept(new LogExprVisitor[R,A](), arg);
      p.logexpr_2.accept(new LogExprVisitor[R,A](), arg);
      ???
    }
    def visit(p : basil_ir.Absyn.BoolNot, arg: A) : R = 
    { /* Code for BoolNot goes here */
      p.logexpr_.accept(new LogExprVisitor[R,A](), arg);
      ???
    }
  }
  class IntRVarVisitor[R,A] extends basil_ir.Absyn.IntRVar.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.IRV, arg: A) : R = 
    { /* Code for IRV goes here */
      //p.bident_;
      p.inttype_.accept(new IntTypeVisitor[R,A](), arg);
      ???
    }
  }
  class BVRVarVisitor[R,A] extends basil_ir.Absyn.BVRVar.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BVRV, arg: A) : R = 
    { /* Code for BVRV goes here */
      //p.bident_;
      p.bvtype_.accept(new BVTypeVisitor[R,A](), arg);
      ???
    }
  }
  class BoolRVarVisitor[R,A] extends basil_ir.Absyn.BoolRVar.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BRV, arg: A) : R = 
    { /* Code for BRV goes here */
      //p.bident_;
      p.booltype_.accept(new BoolTypeVisitor[R,A](), arg);
      ???
    }
  }
  class BoolLiteralVisitor[R,A] extends basil_ir.Absyn.BoolLiteral.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BoolLiteral_true, arg: A) : R = 
    { /* Code for BoolLiteral_true goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BoolLiteral_false, arg: A) : R = 
    { /* Code for BoolLiteral_false goes here */
      ???
    }
  }
  class BVUnOpVisitor[R,A] extends basil_ir.Absyn.BVUnOp.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BVUnOp_bvnot, arg: A) : R = 
    { /* Code for BVUnOp_bvnot goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVUnOp_bvneg, arg: A) : R = 
    { /* Code for BVUnOp_bvneg goes here */
      ???
    }
  }
  class BVBinOpVisitor[R,A] extends basil_ir.Absyn.BVBinOp.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BVBinOp_bvand, arg: A) : R = 
    { /* Code for BVBinOp_bvand goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvor, arg: A) : R = 
    { /* Code for BVBinOp_bvor goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvadd, arg: A) : R = 
    { /* Code for BVBinOp_bvadd goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvmul, arg: A) : R = 
    { /* Code for BVBinOp_bvmul goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvudiv, arg: A) : R = 
    { /* Code for BVBinOp_bvudiv goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvurem, arg: A) : R = 
    { /* Code for BVBinOp_bvurem goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvshl, arg: A) : R = 
    { /* Code for BVBinOp_bvshl goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvlshr, arg: A) : R = 
    { /* Code for BVBinOp_bvlshr goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvnand, arg: A) : R = 
    { /* Code for BVBinOp_bvnand goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvnor, arg: A) : R = 
    { /* Code for BVBinOp_bvnor goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvxor, arg: A) : R = 
    { /* Code for BVBinOp_bvxor goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvxnor, arg: A) : R = 
    { /* Code for BVBinOp_bvxnor goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvcomp, arg: A) : R = 
    { /* Code for BVBinOp_bvcomp goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvsub, arg: A) : R = 
    { /* Code for BVBinOp_bvsub goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvsdiv, arg: A) : R = 
    { /* Code for BVBinOp_bvsdiv goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvsrem, arg: A) : R = 
    { /* Code for BVBinOp_bvsrem goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvsmod, arg: A) : R = 
    { /* Code for BVBinOp_bvsmod goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVBinOp_bvashr, arg: A) : R = 
    { /* Code for BVBinOp_bvashr goes here */
      ???
    }
  }
  class BVLogicalBinOpVisitor[R,A] extends basil_ir.Absyn.BVLogicalBinOp.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BVLogicalBinOp_bvule, arg: A) : R = 
    { /* Code for BVLogicalBinOp_bvule goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVLogicalBinOp_bvugt, arg: A) : R = 
    { /* Code for BVLogicalBinOp_bvugt goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVLogicalBinOp_bvuge, arg: A) : R = 
    { /* Code for BVLogicalBinOp_bvuge goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVLogicalBinOp_bvslt, arg: A) : R = 
    { /* Code for BVLogicalBinOp_bvslt goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVLogicalBinOp_bvsle, arg: A) : R = 
    { /* Code for BVLogicalBinOp_bvsle goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVLogicalBinOp_bvsgt, arg: A) : R = 
    { /* Code for BVLogicalBinOp_bvsgt goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVLogicalBinOp_bvsge, arg: A) : R = 
    { /* Code for BVLogicalBinOp_bvsge goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVLogicalBinOp_bveq, arg: A) : R = 
    { /* Code for BVLogicalBinOp_bveq goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVLogicalBinOp_bvneq, arg: A) : R = 
    { /* Code for BVLogicalBinOp_bvneq goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BVLogicalBinOp_bvult, arg: A) : R = 
    { /* Code for BVLogicalBinOp_bvult goes here */
      ???
    }
  }
  class IntBinOpVisitor[R,A] extends basil_ir.Absyn.IntBinOp.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.IntBinOp_intadd, arg: A) : R = 
    { /* Code for IntBinOp_intadd goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.IntBinOp_intmul, arg: A) : R = 
    { /* Code for IntBinOp_intmul goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.IntBinOp_intsub, arg: A) : R = 
    { /* Code for IntBinOp_intsub goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.IntBinOp_intdiv, arg: A) : R = 
    { /* Code for IntBinOp_intdiv goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.IntBinOp_intmod, arg: A) : R = 
    { /* Code for IntBinOp_intmod goes here */
      ???
    }
  }
  class IntLogicalBinOpVisitor[R,A] extends basil_ir.Absyn.IntLogicalBinOp.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.IntLogicalBinOp_inteq, arg: A) : R = 
    { /* Code for IntLogicalBinOp_inteq goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.IntLogicalBinOp_intneq, arg: A) : R = 
    { /* Code for IntLogicalBinOp_intneq goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.IntLogicalBinOp_intlt, arg: A) : R = 
    { /* Code for IntLogicalBinOp_intlt goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.IntLogicalBinOp_intle, arg: A) : R = 
    { /* Code for IntLogicalBinOp_intle goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.IntLogicalBinOp_intgt, arg: A) : R = 
    { /* Code for IntLogicalBinOp_intgt goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.IntLogicalBinOp_intge, arg: A) : R = 
    { /* Code for IntLogicalBinOp_intge goes here */
      ???
    }
  }
  class BoolBinOpVisitor[R,A] extends basil_ir.Absyn.BoolBinOp.Visitor[R,A]
  {
    def visit(p : basil_ir.Absyn.BoolBinOp_booleq, arg: A) : R = 
    { /* Code for BoolBinOp_booleq goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BoolBinOp_boolneq, arg: A) : R = 
    { /* Code for BoolBinOp_boolneq goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BoolBinOp_booland, arg: A) : R = 
    { /* Code for BoolBinOp_booland goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BoolBinOp_boolor, arg: A) : R = 
    { /* Code for BoolBinOp_boolor goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BoolBinOp_boolimplies, arg: A) : R = 
    { /* Code for BoolBinOp_boolimplies goes here */
      ???
    }
    def visit(p : basil_ir.Absyn.BoolBinOp_boolequiv, arg: A) : R = 
    { /* Code for BoolBinOp_boolequiv goes here */
      ???
    }
  }
}
